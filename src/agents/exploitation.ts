import { BaseAgent } from "./base-agent.js";
import { 
    EXPLOIT_INJECTION_SYSTEM_PROMPT, 
    EXPLOIT_XSS_SYSTEM_PROMPT, 
    EXPLOIT_AUTH_SYSTEM_PROMPT, 
    EXPLOIT_AUTHZ_SYSTEM_PROMPT, 
    EXPLOIT_SSRF_SYSTEM_PROMPT 
} from "../ai/prompts.js";
import { VulnType } from "./vulnerability.js";

const PROMPT_MAP: Record<VulnType, string> = {
    'injection': EXPLOIT_INJECTION_SYSTEM_PROMPT,
    'xss': EXPLOIT_XSS_SYSTEM_PROMPT,
    'auth': EXPLOIT_AUTH_SYSTEM_PROMPT,
    'authz': EXPLOIT_AUTHZ_SYSTEM_PROMPT,
    'ssrf': EXPLOIT_SSRF_SYSTEM_PROMPT
};

export class ExploitationAgent extends BaseAgent {
    private type: VulnType;

    constructor(apiKey: string, type: VulnType) {
        super(apiKey, PROMPT_MAP[type]);
        this.type = type;
    }

    async run(input: { url: string; repoPath: string; exploitationQueue: any }): Promise<any> {
        const queueStr = JSON.stringify(input.exploitationQueue, null, 2);
        
        const prompt = `
        Target URL: ${input.url}
        Repository Path: ${input.repoPath}
        
        Exploitation Queue:
        ${queueStr}

        Start your ${this.type.toUpperCase()} Exploitation.
        1. For each hypothesized vulnerability in the queue, attempt to verify it with a real exploit.
        2. Use browser automation or scripts to prove impact.
        3. Capture evidence (logs, screenshots, data).
        4. Produce 'deliverables/${this.type}_exploitation_evidence.md'.
        `;

        const result = await this.executor.execute(prompt);
        return { 
            type: this.type,
            rawOutput: result 
        };
    }
}
